%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CMPT xxx
% Some Semester
% Lab/Assignment/Project X
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
% Original author: % Frits Wenneker (http://www.howtotex.com)
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% Modified by Alan G. Labouseur  - alan@labouseur.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letterpaper, 10pt,DIV=13]{scrartcl} 

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm,xfrac} % Math packages
\usepackage{sectsty} % Allows customizing section commands
\usepackage{graphicx}
\usepackage[lined,linesnumbered,commentsnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{parskip}
\usepackage{lastpage}
\usepackage{lineno}
\usepackage{float}

\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{page \thepage\ of \pageref{LastPage}} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs.

\binoppenalty=3000
\relpenalty=3000

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
   \normalfont \normalsize 
   \textsc{CMPT 435 - Fall 2023 - Dr. Labouseur} \\[10pt] % Header stuff.
   \horrule{0.5pt} \\[0.25cm] 	% Top horizontal rule
   \huge Assignment One  \\     	    % Assignment title
   \horrule{0.5pt} \\[0.25cm] 	% Bottom horizontal rule
}

\author{Alex Tocci \\ \normalsize Mason.Tocci1@Marist.edu}

\date{\normalsize\today} 	% Today's date.

\begin{document}
\maketitle % Print the title

%----------------------------------------------------------------------------------------
%   start Stacks and Queues
%----------------------------------------------------------------------------------------
\section{Stack and Queue}

\subsection{Creating Node Class}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Node Class}, label={code:example}]
        #include <iostream>
        #include <fstream>
        #include <string>
        // Include for std::random_device
        #include <random>
        
        using namespace std;
        
        // Define a Node class for the stack and queue
        class Node {
        public:
            char data;
            Node* next;
        
            Node(char value) : data(value), next(nullptr) {}
        };
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 1-5:} These lines include the necessary C++ standard libraries for our program to run. \\
\textbf{Line 7:} This allows us to use standard C++ functions without needing to prefix them with 'std::'. \\
\textbf{Lines 10-13:} Define a C++ class called 'Node', containing two member variables, 'char data' and 'Node* next'. 'Char data' stores the data associated with the node. 'Node* next' points to the next node in the linked structure or is set to nullptr if there is no next node. \\
\textbf{Line 15:} This is a constructor for the Node class. It initializes a Node object with the given character value 'value' and sets the next pointer to 'nullptr'.


\subsection{Creating Stack Class}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Stack Class}, label={code:example}]
// Create a stack using the Node class
class Stack {
private:
    // Point to the top of the stack
    Node* top;

public:
    Stack() : top(nullptr) {}

    // Push a value onto the stack
    void push(char value) {
        Node* newNode = new Node(value);
        newNode -> next = top;
        top = newNode;
    }

    // Pop the top value from the stack
    char pop() {
        if (isEmpty()) {
            cerr << "Stack is empty." << endl;
            return -1;
        }
        char value = top->data;
        Node* temp = top;
        top = top -> next;
        delete temp;
        return value;
    }

    // Check if the stack is empty
    bool isEmpty() {
        return top == nullptr;
    }
};
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 18-21:} Define a class called 'Stack', containing a 'Node* top' member variable. This top pointer is used to keep track of the top element in the stack. \\
\textbf{Line 24:} This is the constructor of the Stack class. It initializes the top pointer to 'nullptr', indicating an empty stack. \\
\textbf{Lines 27- 31:} This function is used to push (add) a character value onto the stack. It creates a new Node with the given character value. It sets the 'next' pointer of the new 'Node' to point to the current top of the stack, linking the new Node to the previous top element. It updates the 'top' pointer to point to the new 'Node', making it the new top of the stack. \\
\textbf{Lines 34-44:} This function is used to pop (remove) the top character value from the stack. It checks if the stack is empty by calling the 'isEmpty' method. If the stack is not empty, it retrieves the character value stored in the current top Node, creates a temporary pointer (temp) to the current top Node to avoid losing reference to it, updates the 'top' pointer to point to the next Node in the stack, removing the current top Node, deletes the previous top Node to free the memory it occupied, finally, it returns the popped character value. \\
\textbf{Lines 47- 49:} This function is used to check if the stack is empty. It returns 'true' if the 'top' pointer is 'nullptr', indicating an empty stack, and 'false' otherwise.

\subsection{Creating Queue Class}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Queue Class}, label={code:example}]
// Create a queue using the Node class
class Queue {
private:
    Node* front;
    Node* back;

public:
    Queue() : front(nullptr), back(nullptr) {}

    // Enqueue a value into the queue
    void enqueue(char value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            front = back = newNode;
        }
        else {
            back -> next = newNode;
            back = newNode;
        }
    }

    // Dequeue a value from the queue
    char dequeue() {
        if (isEmpty()) {
            cerr << "Queue is empty." << endl;
            return -1;
        }
        char value = front->data;
        Node* temp = front;
        front = front -> next;
        delete temp;
        return value;
    }

    // Check if the queue is empty
    bool isEmpty() {
        return front == nullptr;
    }
};
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 52-55:} Define a class called 'Queue', containing two member varables 'Node* front' and 'Node* back'. The front pointer is used to keep track of the front element in the queue. The back pointer is used to keep track of the back element in the queue. \\
\textbf{Line 58:} This is the constructor of the Queue class. It initializes both 'front' and 'back' pointers to 'nullptr', indicating an empty queue. \\
\textbf{Lines 61-70:} This function is used to enqueue (add) a character value into the queue. It creates a new Node with the given character value. If the queue is empty, it sets both 'front' and 'back' pointers to point to the new 'Node'. This makes the new 'Node' both the front and back of the queue. If the queue is not empty, it adds the new 'Node' to the back of the queue by updating the 'next' pointer of the current back element to point to the new 'Node', and then updates the 'back' pointer to the new 'Node'. \\
\textbf{Lines 73-82:} This function is used to dequeue (remove) the front character value from the queue. It checks if the queue is empty by calling the 'isEmpty' method. If the queue is not empty, retrieves the character value stored in the current front Node, creates a temporary pointer (temp) to the current front Node to avoid losing reference to it, updates the 'front' pointer to point to the next Node in the queue, removing the current front Node, deletes the previous front Node to free the memory it occupied, finally, it returns the dequeued character value. \\
\textbf{Lines 86-89:} This function is used to check if the queue is empty. It returns 'true' if the 'front' pointer is 'nullptr', indicating an empty queue, and 'false' otherwise.

\subsection{Check for palindrome}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Check for Palindrome}, label={code:example}]
// Check if a string is a palindrome (ignoring spaces and capitalization)
bool isPalindrome(const string& str) {
    Stack stack;
    Queue queue;

    // Push characters to the stack and queue (ignoring spaces and converting to lowercase)
    for (char i : str) {
        if (!isspace(i)) {
            stack.push(tolower(i));
            queue.enqueue(tolower(i));
        }
    }

    // Compare characters from the stack and queue
    while (!stack.isEmpty() && !queue.isEmpty()) {
        if (stack.pop() != queue.dequeue()) {
            // Not a palindrome
            return false;
        }
    }

    return true;
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 91-93:} Two data structures are created: a 'Stack' object named 'stack' and a 'Queue' object named 'queue'. \\
\textbf{Lines 96-101:} Check if the current character 'i' is not a space character using the 'isspace' function. If 'i' is not a space, it converts the character 'i' to lowercase using the 'tolower' function, pushes the lowercase character onto the 'stack' using the 'push' method of the 'Stack' object, and enqueues the lowercase character into the 'queue' using the 'enqueue' method of the 'Queue' object. \\
\textbf{Lines 104-109:} This while loop continues as long as both the 'stack' and the 'queue' are not empty. It compares the characters at the front of the 'stack' (using 'stack.pop()') and the front of the 'queue' (using 'queue.dequeue()'). If the characters are not equal, it means that the input string is not a palindrome, and the function returns 'false'.

\subsection{Shuffle}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Shuffle}, label={code:example}]
// Shuffle the array using the Knuth shuffle algorithm with std::random_device seeding
void shuffle(string* arr, int size) {
    random_device rd;
    srand(rd());

    for (int i = size - 1; i > 0; --i) {
        // Generate a random index between 0 and i
        int j = rand() % (i + 1); 
        // Swap elements at i and j
        swap(arr[i], arr[j]);     
    }
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 114-116:} Declare a random device named 'rd'. Random device is used to generate random numbers. Then, we call 'srand(rd())'. 'srand' is a function that initializes the random number generator with a seed value. \\
\textbf{Lines 118-124:} This 'for' loop is used to shuffle the elements of the input array 'arr' using the Knuth shuffle. It starts with 'i' initialized to 'size - 1', which is the index of the last element in the array. The loop continues as long as 'i' is greater than 0. In each iteration of the loop, it generates a random index 'j' between 0 and 'i' using the 'rand()' function. Then, it swaps the elements 'i' and 'j' in the array 'arr' using the 'swap' function.

%----------------------------------------------------------------------------------------
%   end PROBLEM ONE
%----------------------------------------------------------------------------------------

\pagebreak

%----------------------------------------------------------------------------------------
%   start PROBLEM TWO
%----------------------------------------------------------------------------------------

\section{Sorting}
\subsection{Selection Sort}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Selection Sort}, label={code:example}]
// Selection sort 
void selectionSort(string* arr, int size, int& comparisons) {
    for (int i = 0; i < size - 1; ++i) {
        int index = i;
        for (int j = i + 1; j < size; ++j) {
            // Convert both strings to lowercase for comparison
            for (char& ch : arr[j]) {
                ch = tolower(ch);
            }
            for (char& ch : arr[index]) {
                ch = tolower(ch);
            }
            comparisons++;
            // Compare the lowercase strings
            if (arr[j] < arr[index]) {
                index = j;
            }
        }
        // If a smaller element was found, swap it with the current element
        if (index != i) {
            swap(arr[i], arr[index]);
        }
    }
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 126-128:} This for loop iterates over the elements of the array from the beginning to the second-to-last element ('size - 1'). The purpose of this loop is to select the minimum element in the unsorted portion of the array and place it in its correct position. \\
\textbf{Lines 129-142:} This for loop iterates from 'i + 1' to 'size - 1', comparing each element in the unsorted portion of the array with the element at index 'i'. It converts two strings (the one at index 'j' and the one at index 'index') to lowercase using a loop to make the comparison case-insensitive. Then, 'comparisons' is incremented to keep track of the number of comparisons made. Finally, it compares the lowercase strings using the '<' operator. If 'arr[j]' is less than 'arr[index]', it means that the element at index 'j' is smaller, so 'index' is updated to 'j'. \\
\textbf{Lines 144-146:} After the inner loop completes, the 'index' variable contains the index of the smallest element in the unsorted portion of the array. If 'index' is not equal to 'i', it means that a smaller element was found in the unsorted portion of the array. In this case, the elements 'i' and 'index' are swapped using the swap function, placing the smallest element in its correct position in the sorted portion of the array.

\subsection{Insertion Sort}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Insertion Sort}, label={code:example}]
// Insertion sort
void insertionSort(string* arr, int size, int& comparisons) {
    for (int i = 1; i < size; ++i) {
        int j = i;
        while (j > 0) {
            // Convert both strings to lowercase for comparison
            for (char& ch : arr[j]) {
                ch = tolower(ch);
            }
            for (char& ch : arr[j - 1]) {
                ch = tolower(ch);
            }
            comparisons++;
            // Compare the lowercase strings
            if (arr[j] < arr[j - 1]) {
                swap(arr[j], arr[j - 1]);
                --j;
            }
            else {
                break;
            }
        }
    }
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 150-152:} This for loop starts with 'i' initialized to 1 and iterates over the elements of the array from the second element to the last element. The purpose of this loop is to insert each element into its correct position among the previously sorted elements. \\
\textbf{Lines 153-160:} This while loop starts with 'j' initialized to 'i', and it continues as long as 'j' is greater than 0. It converts two strings (the one at index 'j' and the one at index 'j - 1') to lowercase using a loop to make the comparison case-insensitive. \\
\textbf{Lines 161-166:} Then, 'comparisons' is incremented to keep track of the number of comparisons made. Next, It compares the lowercase strings using the '<' operator. If 'arr[j]' is less than 'arr[j - 1]', it means that the element at index 'j' is smaller than the element at index 'j - 1'. In this case, it swaps these two elements using the 'swap' function and decrements 'j' to continue comparing and possibly swapping with previous elements. \\
\textbf{Lines 167-169:}If the comparison (arr[j] < arr[j - 1]) is false, it breaks out of the inner loop. This break occurs when the element at index j is not smaller than the previous element.

\subsection{Merge Sort}
\subsubsection{Merge Function}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Merge Function}, label={code:example}]
// Function to merge two sorted subarrays
void merge(string* arr, int left, int mid, int right, int& comparisons) {
    // Calculate the sizes of the subarrays
    int sizeLeft = mid - left + 1;
    int sizeRight = right - mid;

    // Create temporary arrays for the subarrays
    string* leftArray = new string[sizeLeft];
    string* rightArray = new string[sizeRight];

    // Copy data to temporary arrays
    for (int i = 0; i < sizeLeft; ++i) {
        leftArray[i] = arr[left + i];
    }
    for (int i = 0; i < sizeRight; ++i) {
        rightArray[i] = arr[mid + 1 + i];
    }

    // Merge the two subarrays back into array
    // Index for the left subarray
    int i = 0; 
    // Index for the right subarray
    int j = 0; 
    // Index for the merged array
    int k = left; 

    while (i < sizeLeft && j < sizeRight) {
        // Convert characters to lowercase for case-insensitive comparison
        for (char& ch : leftArray[i]) {
            ch = tolower(ch);
        }
        for (char& ch : rightArray[j]) {
            ch = tolower(ch);
        }

        comparisons++;
        // Compare and merge based on lowercase strings
        if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            ++i;
        }
        else {
            arr[k] = rightArray[j];
            ++j;
        }
        ++k;
    }

    // Copy the remaining elements of leftArray[], if any
    while (i < sizeLeft) {
        arr[k] = leftArray[i];
        ++i;
        ++k;
    }

    // Copy the remaining elements of rightArray[], if any
    while (j < sizeRight) {
        arr[k] = rightArray[j];
        ++j;
        ++k;
    }

    // Delete temporary arrays
    delete[] leftArray;
    delete[] rightArray;
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 174-177:} This function, merge, is a part of the merge sort algorithm and is responsible for merging two sorted subarrays into a single sorted array. First, the sizes of the two subarrays are calculated. 'int sizeLeft = mid - left + 1' calculates the size of the left subarray. 'int sizeRight = right - mid' calculates the size of the right subarray. \\
\textbf{Lines 180-181:} Create Temporary Arrays: 'string* leftArray = new string[sizeLeft]' creates a temporary array to hold the left subarray. 'string* rightArray = new string[sizeRight]' creates a temporary array to hold the right subarray. \\
\textbf{Lines 184-189:} Two 'for' loops are used to copy the data from the original array 'arr' into the 'leftArray' and 'rightArray'.  \\
\textbf{Lines 193-197:} Merge the two subarrays back into the original array 'arr'. Three index variables are used: 'i' for the left subarray, 'j' for the right subarray, 'k' for the merged array. A 'while' loop is used to compare and merge elements from both subarrays until at least one of the subarrays is fully merged. \\
\textbf{Lines 201-208:} Characters in both 'leftArray[i]' and 'rightArray[j]' are converted to lowercase for case-insensitive comparison. Then, the 'comparisons' counter is incremented to keep track of the number of comparisons made during the merge. \\
\textbf{Lines 210-219:} Elements are compared based on their lowercase strings. The smaller element between 'leftArray[i]' and 'rightArray[j]' is copied into the merged array 'arr[k]', and the corresponding index ('i' or 'j') is incremented. The index 'k' is also incremented to indicate the position of the next element in the merged array. \\
\textbf{Lines 222-233:} The two 'while' loops copy any remaining elements from 'leftArray' and 'rightArray' into the merged array 'arr'. \\
\textbf{Lines 236-238:} Finally, the dynamically allocated memory for 'leftArray' and 'rightArray' is freed using the 'delete[]' operator.

\subsubsection{mergeSort Function}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={mergeSort Function}, label={code:example}]
// Merge sort 
void mergeSort(string* arr, int left, int right, int& comparisons) {
    if (left < right) {
        // Find the middle point
        int mid = left + (right - left) / 2;

        // Recursively sort the first and second halves
        mergeSort(arr, left, mid, comparisons);
        mergeSort(arr, mid + 1, right, comparisons);

        // Merge the sorted halves
        merge(arr, left, mid, right, comparisons);
    }
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 240-241:} The function begins with a conditional check. It checks if 'left' (the left index of the current subarray) is less than 'right' (the right index of the current subarray). \\
\textbf{Line 243:} If the condition is met, the function proceeds to find the middle point of the current subarray. It calculates the midpoint 'mid' by taking the average of 'left' and 'right'. This determines the point at which the subarray is divided into two halves. \\
\textbf{Lines 246-247:} The function recursively calls itself to sort the two halves of the current subarray. The first recursive call sorts the left half of the subarray from index 'left' to 'mid'. The second recursive call sorts the right half of the subarray from index 'mid + 1' to 'right'. These recursive calls split the subarrays into smaller and smaller pieces until they reach the base case, where they contain only one element. \\
\textbf{Line 250:} Once the left and right halves of the subarray are sorted, the merge function is called to merge them back together into a single sorted subarray.

\subsection{Quick Sort}
\subsubsection{Partition Function}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Partition Function}, label={code:example}]
// Partition function for quick sort
int partition(string* arr, int low, int high, int& comparisons) {
    // Choose the rightmost element as the pivot
    string pivot = arr[high]; 
    // Index of the smaller element
    int i = (low - 1); 

    for (int j = low; j <= high - 1; ++j) {
        // Convert both strings to lowercase for comparison
        for (char& ch : arr[j]) {
            ch = tolower(ch);
        }
        for (char& ch : pivot) {
            ch = tolower(ch);
        }

        comparisons++;
        // Compare the lowercase strings
        if (arr[j] < pivot) {
            ++i; 
            swap(arr[i], arr[j]);
        }
    }

    // Swap the pivot element
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 256-258:} Thish function starts by selecting the rightmost element in the given subarray (specified by high) as the pivot. In this implementation, the pivot is stored in the pivot variable. 'i' is initialized to 'low - 1'. It will be used to keep track of the index of the smaller element during the partitioning process. \\
\textbf{Lines 260-274:} The 'for' loop iterates through the elements of the subarray from 'low' to 'high - 1'. This loop compares each element with the pivot and rearranges them accordingly. Inside the loop, both the current element ('arr[j]') and the pivot are converted to lowercase characters to ensure a case-insensitive comparison. For each element, the function increments the 'comparisons' counter to keep track of the number of comparisons made during the partition, and compares the lowercase strings of the element at index 'j' and the pivot using the '<' operator. If the element is less than the pivot, it increments 'i' to mark the position of the smaller element and swaps the element at index 'i' with the element at index 'j'. \\
\textbf{Lines 278-280:} The pivot element is swapped with the element at index 'i + 1', placing the pivot in its correct sorted position. The function returns the index '(i + 1)' as it represents the correct position of the pivot element in the sorted array.

\subsubsection{quickSort Function}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={quickSort Function}, label={code:example}]
// Quick sort
void quickSort(string* arr, int low, int high, int& comparisons) {
    if (low < high) {
        // Find the pivot element such that
        // element smaller than pivot are on the left and
        // elements greater than pivot are on the right
        int pivotIndex = partition(arr, low, high, comparisons);

        // Recursively sort the subarrays
        quickSort(arr, low, pivotIndex - 1, comparisons);
        quickSort(arr, pivotIndex + 1, high, comparisons);
    }
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Line 283:} This function starts with a conditional check. It verifies whether the 'low' index is less than the 'high' index. \\
\textbf{Line 287:} If the condition is met, the function proceeds to find a pivot element and partition the subarray. The partition function is called to do this. \\
\textbf{Lines 290-293:} After partitioning the subarray, the 'quickSort' function is called recursively twice to sort the left and right subarrays. The first recursive call ('quickSort(arr, low, pivotIndex - 1, comparisons)') sorts the left subarray (elements less than the pivot) from index 'low' to 'pivotIndex - 1'. The second recursive call ('quickSort(arr, pivotIndex + 1, high, comparisons)') sorts the right subarray (elements greater than the pivot) from index 'pivotIndex + 1' to 'high'. These recursive calls continue until all subarrays contain zero or one element, which is the base case for the recursion.


%----------------------------------------------------------------------------------------
%   end PROBLEM Two
%----------------------------------------------------------------------------------------

\pagebreak

%----------------------------------------------------------------------------------------
%   start PROBLEM Three
%----------------------------------------------------------------------------------------
\section{Main Function}
\subsection{Test Stack and Queue}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Test Stack and Queue}, label={code:example}]
int main() {
    // Test the stack
    Stack testStack;
    testStack.push('A');
    testStack.push('B');
    testStack.push('C');

    cout << "Stack contents: ";
    while (!testStack.isEmpty()) {
        cout << testStack.pop() << " ";
    }
    cout << endl;

    // Test the queue
    Queue testQueue;
    testQueue.enqueue('A');
    testQueue.enqueue('B');
    testQueue.enqueue('C');

    cout << "Queue contents: ";
    while (!testQueue.isEmpty()) {
        cout << testQueue.dequeue() << " ";
    }
    cout << endl;
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 296-299:} Create an instance of a stack and push three characters onto it. The elements are added to the top of the stack in the order they are pushed. \\
\textbf{Lines 301-305:} The 'while' loop will continue as long as the stack is not empty.
Within the loop, 'testStack.pop()' pops the top element from the stack and prints it to the standard output. The loop continues until the stack is empty, and all elements ('C', 'B', 'A') are popped and printed. \\
\textbf{Lines 309-311:} Create an instance of a queue and enqueue three characters onto it. The elements are added to the back of the queue in the order they are enqueued. \\
\textbf{Lines 313-317:} The 'while' loop will continue as long as the queue is not empty. Within the loop, 'testQueue.dequeue()' dequeues the front element from the queue and prints it to the standard output. The loop continues until the queue is empty, and all elements ('A', 'B', 'C') are dequeued and printed.

\subsection{Read 'magicitems.txt' and store items into an array}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Store Items in Array}, label={code:example}]
// Read all lines of magicitems.txt and put them in an array
// Open the magicitems.txt file
ifstream file("magicitems.txt");

// Handle failure
if (!file) 
{
    cerr << "Failed to open magicitems.txt" << endl;
    return 1;
}

// Count the number of lines in the file
int magicItemsSize = 0;
string line;
while (getline(file, line)) 
{
    magicItemsSize++;
}

// Close and reopen the file to read from the beginning
file.close();
file.open("magicitems.txt");

// Create a dynamically allocated array
string* magicItemsArray = new string[magicItemsSize];

// Read the file line by line and store each line in the array
int index = 0;
while (getline(file, line)) 
{
    magicItemsArray[index] = line;
    index++;
}

// Close the file
file.close();
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Line 320:} Open the file 'magicitems.txt' for reading. \\
\textbf{Lines 323-327:} Check if the file was successfully opened. If the file cannot be opened, it prints an error message to the standard error stream ('cerr') and exits the program. \\
\textbf{Lines 330-335:} Read the file line by line using 'getline' and count the number of lines in the file. Increment the 'magicItemsSize' variable for each line encountered. \\
\textbf{Lines 338-339:} Close and reopen the file to read from the beginning. \\
\textbf{Line 342:} Dynamically allocate an array of strings named 'magicItemsArray' with a size equal to the number of lines counted earlier ('magicItemsSize'). \\
\textbf{Lines 345-350:} Read the file line by line and store each line in the array. \\
\textbf{Line 353:} Close the file.

\subsection{Check for Palindromes}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Check for Palindromes}, label={code:example}]
cout << "\nPalindromes: " << endl;
// Check each line in the array for palindromes and print it if it is
for (int i = 0; i < magicItemsSize; ++i) {
    if (isPalindrome(magicItemsArray[i])) {
        cout << magicItemsArray[i] << endl;
    }
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Lines 354-360:} The for loop iterates over each line in the 'magicItemsArray'. The loop index 'i' ranges from 0 to 'magicItemsSize - 1'. Inside the loop, 'isPalindrome(magicItemsArray[i])' is used to check if the current line in the array ('magicItemsArray[i]') is a palindrome. If 'isPalindrome' returns 'true', it means that the current line is a palindrome and will be printed to the standard output.

\subsection{Selection Sort}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Selection Sort}, label={code:example}]
// Shuffle before sorting
shuffle(magicItemsArray, magicItemsSize);

int comparisonsSelectionSort = 0;
// Sort magicItemsArray using selection sort
selectionSort(magicItemsArray, magicItemsSize, comparisonsSelectionSort);

cout << "\nSorted Magic Items (Selection Sort):" << endl;
for (int i = 0; i < magicItemsSize; ++i) {
    cout << magicItemsArray[i] << endl;
}
cout << "Comparisons in Selection Sort: " << comparisonsSelectionSort << endl;
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Line 362:} This line calls a function named 'shuffle' to shuffle the elements in the 'magicItemsArray'. \\
\textbf{Lines 365-366:} Initialize an integer variable named 'comparisonsSelectionSort' to zero. Sort the 'magicItemsArray' using the selection sort algorithm. The 'comparisonsSelectionSort' variable is passed as a reference to the function, allowing it to count the number of comparisons made during the sorting process. \\
\textbf{Lines 368-371:} Use a 'for' loop to iterate through the sorted 'magicItemsArray' and print each element to the standard output. \\
\textbf{Line 372:} Print the number of comparisons made during the selection sort process.

\subsection{Insertion Sort}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Insertion Sort}, label={code:example}]
// Shuffle before sorting again
shuffle(magicItemsArray, magicItemsSize);

int comparisonsInsertionSort = 0;
// Sort magicItemsArray using selection sort
insertionSort(magicItemsArray, magicItemsSize, comparisonsInsertionSort);

cout << "\nSorted Magic Items (Insertion Sort):" << endl;
for (int i = 0; i < magicItemsSize; ++i) {
    cout << magicItemsArray[i] << endl;
}
cout << "Comparisons in Insertion Sort: " << comparisonsInsertionSort << endl;
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Line 374:} Shuffle the elements in 'magicItemsArray'. \\
\textbf{Lines 376-378:} Initialize an integer variable named 'comparisonsInsertionSort' to zero. Sort the 'magicItemsArray' using the insertion sort algorithm. The 'comparisonsInsertionSort' variable is passed as a reference to the function, allowing it to count the number of comparisons made during the sorting process. \\
\textbf{Lines 380-383:} Use a 'for' loop to iterate through the sorted 'magicItemsArray' and print each element to the standard output. \\
\textbf{Line 384:} Print the number of comparisons made during the insertion sort process.

\subsection{Merge Sort}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Merge Sort}, label={code:example}]
// Shuffle before sorting again
shuffle(magicItemsArray, magicItemsSize);

int comparisonsMergeSort = 0;
// Sort the strings using merge sort in a case-insensitive manner
mergeSort(magicItemsArray, 0, magicItemsSize - 1, comparisonsMergeSort);

cout << "\nSorted Magic Items (Merge Sort):" << endl;
for (int i = 0; i < magicItemsSize; ++i) {
    cout << magicItemsArray[i] << endl;
}
cout << "Comparisons in Merge Sort: " << comparisonsMergeSort << endl;
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Line 386:} Shuffle the elements in 'magicItemsArray'. \\
\textbf{Lines 388-390:} Initialize an integer variable named 'comparisonsMergeSort' to zero. Sort the 'magicItemsArray' using the merge sort algorithm. The 'comparisonsMergeSort' variable is passed as a reference to the function, allowing it to count the number of comparisons made during the sorting process. \\
\textbf{Lines 392-395:} Use a 'for' loop to iterate through the sorted 'magicItemsArray' and print each element to the standard output. \\
\textbf{Line 396:} Print the number of comparisons made during the merge sort process.

\subsection{Quick Sort}
% Insert C++ code with line numbers
\begin{linenumbers}
\begin{lstlisting}[language=C++, caption={Quick Sort}, label={code:example}]
    // Shuffle before sorting again
    shuffle(magicItemsArray, magicItemsSize);

    // Sort magicItemsArray using quick sort
    int comparisonsQuickSort = 0; // Initialize comparisons counter
    quickSort(magicItemsArray, 0, magicItemsSize - 1, comparisonsQuickSort);

    cout << "\nSorted Magic Items (Quick Sort):" << endl;
    for (int i = 0; i < magicItemsSize; ++i) {
        cout << magicItemsArray[i] << endl;
    }

    cout << "Comparisons in Quick Sort: " << comparisonsQuickSort << endl;


    // Delete dynamically allocated memory
    delete[] magicItemsArray;

    return 0;
}
\end{lstlisting}
\end{linenumbers}
\nolinenumbers

\textbf{Line 398:} Shuffle the elements in 'magicItemsArray'. \\
\textbf{Lines 400-402:} Initialize an integer variable named 'comparisonsQuickSort' to zero. Sort the 'magicItemsArray' using the quick sort algorithm. The 'comparisonsQuickSort' variable is passed as a reference to the function, allowing it to count the number of comparisons made during the sorting process. \\
\textbf{Lines 404-407:} Use a 'for' loop to iterate through the sorted 'magicItemsArray' and print each element to the standard output. \\
\textbf{Line 409:} Print the number of comparisons made during the quick sort process. \\
\textbf{Line 413:} Delete dynamically allocated memory.

%----------------------------------------------------------------------------------------
%   end PROBLEM THREE
%----------------------------------------------------------------------------------------

\pagebreak

%----------------------------------------------------------------------------------------
%   start PROBLEM Four
%----------------------------------------------------------------------------------------

\section{Results}

\begin{table}[H]
\centering
\caption{Number of Comparisons}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 & 1 & 2 & 3 & 4 & 5 & Avg \\
\hline
Selection Sort & 221445 & 221445 & 221445 & 221445 & 221445 & 221445 \\
\hline
Insertion Sort & 111238 & 112774 & 107069 & 111565 & 109727 & 110474.6 \\
\hline
Merge Sort & 5435 & 5417 & 5440 & 5405 & 5423 & 5424 \\
\hline
Quick Sort & 7052 & 7407 & 6809 & 7234 & 6815 & 7063.4 \\
\hline
\end{tabular}
\end{table}

\subsection{Selection Sort}
Selection sort has a time complexity of $O(n^2)$ in the worst, average, and best cases. In this case, we always get 221,445 comparisons because the size of the array is fixed at 666, and selection sort performs the same number of comparisons regardless of the initial order of the input. In the code, the outer loop runs for '(size - 1)' iterations, and the inner loop runs for '(size)' iterations in each iteration of the outer loop. This results in a total of $comparisons = (size - 1) * (size) / 2$ comparisons, plugging in 666 for size we get 221,445 comparisons.
\subsection{Insertion Sort} 
Insertion sort has a time complexity of $O(n^2)$ in its worst cases. In the code, the 'for' loop runs for '(size - 1)' iterations. In the code, the 'while' loop runs as long as the selected element ('arr[j]') is less than its previous element ('arr[j - 1]') when compared in lowercase; in the worst case this would be the size of the array, 666. This results in a worst case of $comparisons = (size - 1) * (size) / 2$ comparisons,  plugging in 666 for size we get 221,445 comparisons. To get the average we would divide the worst case by 2, making our average 110722.5.
\subsection{Merge Sort} 
Merge sort has a time complexity of $O(n log n)$ in its worst cases. In the code, the 'merge' function merges two sorted subarrays into a single sorted array. The time complexity of this function is $O(n)$, where n is the total number of elements in the two subarrays. The 'mergeSort' function recursively divides the input array into smaller subarrays until each subarray contains only one element. Then, it merges these subarrays back together in sorted order. The dividing step (the recursion) takes $O(log n)$ time because the array is repeatedly halved. The merging step takes $O(n)$ time per recursion. When adding up the time taken at each level of recursion, you get a total time complexity of $O(n log n)$. Plugging in 666, our worst case is 6246.
\subsection{Quick Sort} 
Quick sort has a time complexity of $O(n log n)$ in its worst cases. In the code, the 'partitioning' function takes a pivot and arranges the elements such that those less than the pivot are on the left, and those greater are on the right. The average time complexity of this function is $O(n)$. In each recursive call to 'quickSort', the partition step splits the array into two subarrays. The size of these subarrays is not necessarily halved, but in the average case, they are expected to be balanced. The partitioning step takes $O(n)$ time per recursion. When adding up the time taken at each level of recursion, you get an average time complexity of $O(n log n)$. Plugging in 666, our average case should be 6246.7.

%----------------------------------------------------------------------------------------
%   end PROBLEM Four
%----------------------------------------------------------------------------------------
\pagebreak


\end{document}
